<!DOCTYPE html>
<html lang="en">

<head>
    <title>Rawer</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <link rel="stylesheet" href="css/fonts.css" type="text/css" />
    <link rel="stylesheet" href="css/grid-columns.css" type="text/css" />
    <link rel="stylesheet" href="css/style.css" type="text/css" />

</head>

<body>
    <header id="main-header">
        <h1 class="h-title">
           Rawer
        </h1>
    </header>
    <div class="grid-container">
        <div class="main-grid-item directory">
            <p><strong>Under Construction</strong></p>
            <p><em>there are many to-dos</em></p>
        </div>
        <div class="main-grid-item articles">
            <article>
                <!-- POST CONTENT TEMPLATE -->

<article class="post-content">
        <a href="">#</a>
    <h1>MozzPoly</h1>
<p><em>Setting up HAL9000, it asked for a domain name. It&#39;ll be running at home, New Place, aka Mozzanella Polytechnic. So I went with mozzpoly.hyperdata.it.</em></p>
<p><a href="https://github.com/modelcontextprotocol/servers">https://github.com/modelcontextprotocol/servers</a></p>
<ul>
<li><p>fix laptop</p>
</li>
<li><p>Home network</p>
</li>
<li><p>CV for Leonardo</p>
</li>
<li><p>semem is lightweight, componentized trustgraph</p>
</li>
<li><p>fuseki xmpp etc in docker</p>
</li>
</ul>
<p>#:ops distracted - Model Context Protocol! It ties in nicely with the current #:transmissions activity</p>
<p>#:todo write out how I&#39;ve been using AI, search, <em>everything</em>, myself. Rephrase into a form that AI can help with</p>
<p>#:todo pull runCommand() out of /home/danny/github-danny/transmissions/tests/integration/test_apps.spec.js</p>
<p>#:todo a processor disable flag would be useful (create the instance, just bypass run) - see Claude chat on messaging explain</p>
<h2>Model Context Protocol</h2>
<p><a href="https://github.com/danja/chauvin.git">https://github.com/danja/chauvin.git</a></p>
<p>/home/danny/github-danny/hyperdata/workspaces/hyperdata/articles/chauvin/about.md</p>
<p>/home/danny/github-danny/hyperdata/workspaces/hyperdata/entries/2024-11-28_mcp-start.md</p>
<p>/home/danny/github-danny/hyperdata/workspaces/hyperdata/todo/mcp.md</p>
<p>I should use <code>/journal</code> under <code>hyperdata</code> for this...</p>
<h2>Home Network</h2>
<ul>
<li>set up tunnelling to desktop</li>
<li>vnc</li>
<li></li>
</ul>
<h2>Transmissions</h2>
<p>rpp:Signature? better, trm:</p>
<ul>
<li>Http</li>
<li>MCP <a href="https://github.com/modelcontextprotocol/create-typescript-server.git">https://github.com/modelcontextprotocol/create-typescript-server.git</a></li>
</ul>
<h3>Model Context Protocol</h3>
<p>My gut says the server is worth  making standalone, at least in the first instance.</p>
<p><a href="https://github.com/danja/chauvin.git">https://github.com/danja/chauvin.git</a></p>
<p>#:todo sort inconsistency in loading from config, some use configKey
/home/danny/github-danny/transmissions/src/applications/test_fs-rw/config.ttl uses key
something uses the instance URI : preferred</p>
<h2>Links</h2>
<ul>
<li><a href="https://www.anthropic.com/news">Anthropic News</a></li>
<li><a href="https://github.com/modelcontextprotocol">Model Context Protocol</a>, <a href="https://github.com/modelcontextprotocol/specification">spec</a></li>
</ul>

</article>
<p class="post-title h-cinzel">
    <a href="">
        
    </a>
</p> <em></em><!-- POST CONTENT TEMPLATE -->

<article class="post-content">
        <a href="">#</a>
    <h1>Trust Graphs!</h1>
<p><em>I had a server issue - overshooting mem &amp; cpu limits. I&#39;d forgotten I&#39;d left <a href="https://trustgraph.ai/">TrustGraph</a> running. #:ops</em></p>
<p>Problem identified with :</p>
<pre><code class="language-sh">free -m
ps -eo pmem,pcpu,rss,vsize,args | sort -k 1 -r | less
</code></pre>
<p><a href="https://techdocs.akamai.com/cloud-computing/docs/troubleshooting-memory-issues-on-compute-instances">https://techdocs.akamai.com/cloud-computing/docs/troubleshooting-memory-issues-on-compute-instances</a></p>
<p>Fixed with :</p>
<pre><code class="language-sh">cd /home/services/trustgraph/docker-compose/
docker compose -f danja-tg-openai-neo4j.yaml down -v
docker ps
</code></pre>
<p><a href="https://trustgraph.ai/docs/running/docker">https://trustgraph.ai/docs/running/docker</a></p>

</article>
<p class="post-title h-cinzel">
    <a href="">
        
    </a>
</p> <em></em><!-- POST CONTENT TEMPLATE -->

<article class="post-content">
        <a href="">#</a>
    <h1>Groundhog</h1>
<p><em>I want to avoid those days.</em></p>
<p>I really want to get on with new code while the plan details are still in my head. But I&#39;d better do a little to solidify #:transmissions. Started as below. Very quickly semi-distracted.</p>
<p>For #:postcraft docs, I want to get past the <em>build-everything</em> setup I&#39;ve got currently. I want the system to watch for fs changes and update in near real time.</p>
<p>I have an approach I think will work. It&#39;s something Claude should be good at building, but I need to check for refactorings that would be useful to do first.</p>
<p>The two main components are general-purpose, but the #:postcraft docs  :</p>
<ol>
<li>#:transmissions running as a daemon (quasi-micro) service with a HTTP API</li>
<li>a #:transmission running as a client that will post job descriptions to the server</li>
</ol>
<p><em>Remember requirements for #:kia - this should be able to act as an agent.</em></p>
<h2>Service</h2>
<p>I&#39;ve had success with running node services under pm2, but I can start and stop things manually for now.</p>
<p>It might be useful to use the (unsafe) system call processor I started for service runtime updating.</p>
<h2>Client</h2>
<p>A big requirement here is a clear description of the description - for this I need to clarify the #:transmissions system structure.</p>
<p>The #:postcraft use case is a nice one though. To watch for fs changes it&#39;ll need to operate as a local service, ie. pretty much the same as the server component. But I can start with a very much reduced form.</p>
<p>a transmissions service is running continually.</p>
<p>It watches for filesystem changes in a given directory</p>
<hr>
<p>#:ops. While building up some tests I hit Claude&#39;s message limit. Ok, for 7pm (it&#39;s now 3:15pm) :</p>
<pre><code class="language-ho">Can you please create a ho doc, as well as step-by-step instructions on how to create a test application, together with a set of files that can act as a template, following the style of test_fs-rw . Please give me complete individual artifacts for each of these
</code></pre>
<hr>
<h2>Solidify...</h2>
<ol>
<li>test coverage</li>
<li>docs</li>
<li>GitHub CI/CD</li>
<li>refactoring</li>
</ol>
<h2>1. Test Coverage</h2>
<p>I <strong>really</strong> need proper coverage.</p>
<p>Ok, now nyc is mostly working : <code>http://localhost/GITHUB-DANNY/transmissions/spec/coverage/lcov-report/</code></p>
<h2>2. Docs</h2>
<h3>jsdocs</h3>
<p>Ew. I want to customise quite a lot, come back to this later.</p>
<h3>#:postcraft</h3>
<h2>3. GitHub CI/CD</h2>
<p>I have looked into it before...completely forgotten.</p>
<h2>4. Refactoring</h2>
<p>I sketched out a plan last week, need to revisit.</p>
<h2>5. Tests</h2>
<p>I need some integration tests that start with CLI calls.</p>
<h3>CLI Core Tests</h3>
<p>Did I make a <code>ConditionTest</code> processor? Compare the <code>message</code> with a pattern, match/no match for test result.</p>
<p>Hmm.</p>
<pre><code class="language-prompt">I would like an integration test runner `tests/integration/test_apps.spec.js` in a similar form to `tests/integration/fs-rw.spec.js` that will do the following :

* scan for directories that match `src/applications/test_*`, eg. `src/applications/test_fs-rw`
then for each of these :
* set up test data as necessary in `src/applications/*/data/input`, eg. `src/applications/test_fs-rw/data/input/input-01.md`
* run them : eg. `./trans test_fs-rw`
* compare the output message with what is expected, which (if necessary) will appear in a file eg. `src/applications/test_fs-rw/data/output/required-01.md`

Provision should be included to support trying different command-line arguments, so eg. an input message may be given via a string or filename, and/or a target (where a `manifest.ttl` and/or modules may be found), eg :
` ./trans ../trans-apps/applications/test_module-load -m &#39;{&quot;first&quot;:&quot;one&quot;,&quot;second&quot;:&quot;two&quot;}&#39;`

Please create the necessary code as complete artifacts.
</code></pre>
<p>Yay! That worked a treat (by the 6th cycle).</p>
<ul>
<li><code>(:DatasetReader :FileWriter)</code></li>
<li></li>
</ul>
<h3>FS Remote App Test</h3>
<pre><code class="language-sh">./trans ../trans-apps/applications/test_module-load -m &#39;{&quot;first&quot;:&quot;one&quot;,&quot;second&quot;:&quot;two&quot;}&#39;
</code></pre>

</article>
<p class="post-title h-cinzel">
    <a href="">
        
    </a>
</p> <em></em><!-- POST CONTENT TEMPLATE -->

<article class="post-content">
        <a href="">#</a>
    <h1>New features can be their own tests</h1>
<p><em>Something to go in my #:um methodology, as and when I can state it a little more formally</em></p>
<p>I have the common tendency to rush ahead building the fun new shiny interesting bits, and neglecting the existing <em>working code</em>. It&#39;s kind-of axiomatic in dev that you need tests. Coincidentally, this morning I saw reference to a book <a href="https://www.amazon.com/dp/1732102201?ref=blog.pragmaticengineer.com">A Philosophy of Software Design</a> (John Ousterhout, 2018) which apparently downplays tests in favour of comments. To which I&#39;ll give a resounding <strong><em>wtf?!</em></strong>. I&#39;ve lost the link of a blog post which the not-much-testing aspect more plainly, but Gergely Orosz&#39;s <a href="https://blog.pragmaticengineer.com/a-philosophy-of-software-design-review/">A Philosophy of Software Design: My Take (and a Book Review)</a> answer to mucho-comments rings true.</p>
<h3>Regarding comments -</h3>
<p>For sure comments are must have, <em>at the module/class/method levels</em>. Document the API right next to its code, use a tool to extract &amp; publish the formal bits, pad with friendlier text at a different layer. <em>Some</em> inline comments are desirable, but only when operation isn&#39;t immediately evident from the code. This is often the case when lesser-known libs are used, or when an unusual idiom is called into play. I use inline comments a lot, but almost always there with be a <code>// TODO : ...</code> nearby.</p>
<p>To use the lingo of men with greyer beards than mine, lots of inline comments are a <em>Bad Smell</em>. A strong hint that refactoring is needed. Pull that stuff out into its own functional block, give it a meaningful name.  </p>
<h3>Back to tests -</h3>
<p><strong>Impatience is more motivational than Best Practices</strong>.</p>
<p>I guess this is an instance of a general tendency in human cognition : the <strong>more visceral</strong> an experience is, the <strong>more attention</strong> it will receive.   </p>
<p>Acknowledge that, find a workaround if its called for. As in this case.</p>
<h2>Scenario</h2>
<p>I have wasted lots over the past couple weeks having to backtrack a long way due to <em>more haste...</em> Today I decided to bite the bullet and improve my testing. I&#39;d set up <a href="https://jasmine.github.io">Jasmine</a> right at the start of the project, ready to support both unit and integration tests. Today I got <a href="https://github.com/istanbuljs/nyc">nyc</a> (the CLI of <a href="https://istanbul.js.org/">Istanbul</a>) working after a fashion from <code>npm</code>. This told me what I already knew - my test coverage was ballpark 1%. Not as terrible as it sounds, because I was running the #:postcraft #:transmission most days to publish this blog, and that exercised lots of the code. <em>Errm,</em> and frequently it didn&#39;t work.</p>
<p>But here&#39;s the thing. Aside from the #:transmissions project&#39;s core engine bits, the application functionality is strongly decomposed. To develop most new features/applications, I start by making a fairly minimal runner for that particular processor. For example, one that is still in a somewhat hacky state is a thing to restructure a message expressed in JSON structure (as preparation for rending in markdown of Claude data export). To get this working I rigged up a little thing where I gave it a small sample JSON file (Claude&#39;s stuff is huge), saving the output to visually check.    </p>
<p>I&#39;d got a bunch of these. Most with the word <code>test</code> in their name - subtle hint!</p>
<p>So earlier I did a fresh s/repopack/<a href="https://github.com/yamadashy/repomix">repomix</a> of my codebase, gave this to Claude as project knowledge (I reuse the same project, system prompt stays the same I just update the knowledge, start new chat sessions). Spent 15 mins on a prompt. After a further 30 mins maybe (6 artifact revisions needed), I had a functioning Jasmine test spec that will run through each <code>src/applications/test_*</code> dir, pick up a tiny JSON config file and run the application.</p>
<p>In the space of an hour I&#39;d effectively upped my test coverage to something like 50%.</p>
<p>I still need to do a bit of work on the flow &amp; reporting, right now some of the mini-apps do break with exceptions and the runner doesn&#39;t notice.</p>
<p>But essentially these things can make true integration tests, because the test is totally about a (mini) application setup, without any real artificiality coming in from the test framework.</p>
<p>So these, as running code, can be a single source of truth on how things work (once they do...). Docs &amp; RDF/OWL descriptions will be generate from there.  </p>

</article>
<p class="post-title h-cinzel">
    <a href="">
        
    </a>
</p> <em></em><!-- POST CONTENT TEMPLATE -->

<article class="post-content">
        <a href="">#</a>
    <h1>trans-dev</h1>
<p>#:yapp : Yet Another Placeholder Project : <a href="https://github.com/danja/trans-dev">https://github.com/danja/trans-dev</a></p>
<p><em>Maybe</em> more justifiable than usual...</p>
<p>Quite early on with #:transmissions it occurred to me that I could do with something like a specialized IDE for the thing. During these stages of dev, it&#39;s convenient to have something that runs on the desktop, for the sake of easy fs access.</p>
<p>Which led me to play with #:pulsar editor, start making #:hyperdata-desktop. (Which has been troublesome at times, largely due to the fact that Pulsar has to be built with an older version of node. But I&#39;ll be sticking with it for now at least, it seems like it carries less baggage than eg. making VSCode plugins, it feels more manageable somehow).  </p>
<p>So far I&#39;ve only been using #:hyperdata-desktop as a text editor with <em>General MIDI</em> bells &amp; whistle - markdown, tabs, file tree, search, terminal etc. (I&#39;m typing in it right now). Where I imagined going next with this was adding a few buttons to do #:transmissions-specific operations, comparable to running bash scripts rather than having to remember everything in the regular terminal CLI.</p>
<p><strong>However</strong>, the past week or two I&#39;ve spent a <em>lot</em> of time bouncing between the raw JS and the declarative bits of #:transmissions. It&#39;s occurred to me that something akin to Jupyter notebooks would be very desirable. I had a chat with Claude about this, with the result that it appears my best approach would be to create a lightweight thing like Jupyter. I can&#39;t deny I often go *<em>Not Invented Here</em> in the way I develop things, but this is mostly motivated by my desire to know what&#39;s going on under the hood, rather that #:link adopting <strong>Yet Another Framework</strong>.</p>
<p>An extra motivation here is that I want to include #:semweb features from the ground up. Web-native is a requirement.</p>
<p>Claude helped put together the Jupyter-like requirements (with excellent hints re. libs to look at), my only notable extra bit being an abstraction of storage. I want to be able to use native OS fs, HTTP methods against a suitably-shaped server setup, as well as a SPARQL store. All this lends itself to being built incrementally, as things are needed, with Claude or another of his species doing the grunt work.</p>
<p>I&#39;ll make it a submodule of #:hyperdata per <code>/home/danny/github-danny/hyperdata/workspaces/hyperdata/articles/a-package-starter.md</code></p>
<p>It&#39;ll need stuff for npm and its own (#:postcraft) doc bits. I might as well do the same for #:squirt (a posting PWA) now. That will be quasi-standalone, but sits inside #:farelo, docs can go there.</p>
<pre><code class="language-sh">cd /home/danny/github-danny/hyperdata/packages
git submodule add https://github.com/danja/trans-dev.git trans-dev

cd trans-dev
npm init -y

mkdir ~/github-danny/hyperdata/packages/trans-dev/docs
cp -r ~/github-danny/postcraft/postcraft-template ~/github-danny/hyperdata/packages/trans-dev/docs/postcraft
ln -s ~/github-danny/hyperdata/packages/trans-dev/docs/postcraft/content-raw ~/github-danny/hyperdata/workspaces/trans-dev
</code></pre>
<p>Hmm. Where&#39;s #:farelo again..?</p>
<p><code>/home/danny/github-danny/hyperdata/packages/farelo</code></p>
<p>Ok.
I know I&#39;ve got #:fam under #:farelo, #:squirt should be the same. I guess easiest is :</p>
<pre><code class="language-sh">cd ~/github-danny/hyperdata/packages/farelo
cp -r form-a-matic squirt
</code></pre>
<p>Then delete unwanted stuff.
Jeez, cp took a couple of seconds...</p>
<p>Heh, <code>node_modules</code> innit mate.</p>
<p>I&#39;d better get the Claude chat into #:trans-dev.</p>
<p>Export...</p>
<p>Hmm. What are the odds <code>/home/danny/github-danny/transmissions/src/applications/claude-json-converter</code> still works...</p>
<pre><code class="language-sh">TypeError: Cannot read properties of undefined (reading &#39;toString&#39;)
    at MarkdownFormatter.extractMarkdown (file:///home/danny/github-danny/transmissions/src/processors/staging/MarkdownFormatter.js:42:94)
    at MarkdownFormatter.process (file:///home/danny/github-danny/transmissions/src/processors/staging/MarkdownFormatter.js:21:32)
</code></pre>
<p>Yeah, predictable <strong>tests you idiot!</strong></p>
<p>Though it looks like <code>MarkdownFormatter</code> was called loads of times before it failed.</p>
<p>Heh, not a difficult one. The bit that listed other <code>key:value</code> in the message was falling over with  <code>key = subtask</code>, when the value was undefined.</p>
<p><code>MarkdownFormatter</code> has at least one hardcoded path, but I don&#39;t need it for anything else right now so no probs.</p>
<p>Target path is like
<code>&quot;filepath&quot;: &quot;/home/danny/github-danny/hyperdata/docs/postcraft/content-raw/chat-archives/md/6de5/2024-11-09_500.m...&quot; </code></p>
<p>Ok, relevant chat is under <code>/home/danny/github-danny/hyperdata/workspaces/hyperdata/chat-archives/md/2ea9</code></p>
<p>Doesn&#39;t look like I implemented #:todo artifact saving. Not to worry, only a few to download.</p>
<p>All placed under <code>/home/danny/github-danny/hyperdata/workspaces/trans-dev/claude-chat</code></p>
<p>I&#39;ll just do <code>/home/danny/github-danny/hyperdata/workspaces/trans-dev/todo/next-steps.md</code></p>
<h2>Links</h2>
<ul>
<li><a href="https://vscodium.com/">VSCodium</a> is a community-driven, freely-licensed binary distribution of Microsoftâ€™s editor VS Code</li>
</ul>

</article>
<p class="post-title h-cinzel">
    <a href="">
        
    </a>
</p> <em></em>
            </article>
        </div>
        <div class="main-grid-item about">
            <!--
            <h2>About</h2>
            
            -->
        </div>
    </div>
</body>

</html>